#Chapter 9: Memeryspace and Namespace
---
:bowtie:
1. 良好的程序包含三个部分
    * 头文件: 包含结构声明和使用这些结构的函数的原型;
    * 源文件: 包含与结构有关的函数的代码;
    * 源文件: 包含调用与结构相关的函数的代码;
2. 在链接编译模块的时候,一定要确保所有对象文件或库都是由同一个编译器生成的,这样可以消除可能的链接错误;
3. 关键字extern表明是引用声明,即声明引用在其它地方定义的变量;
4. 关键字volatile表明,若变量在多个地方引用,不要将变量缓存,每次使用时都在变量地址上查找,因为也许由于硬件的原因,变量发生了改变;
5. 关键字mutable指出,即使结构(或类)变量为const,其某个成员也可以被修改;
```C++
    struct data
    {
        char name[30];
        mutable int accesses;
        ...
    };
    const data veep = { "Test",0,...};
    ++veep.accesses; 
``` 
6. 对于非内联函数,程序只能包含一个定义;
7. 对于内联函数,同一个函数的所有内联定义都必须相同;
8. 使用new分配空间并初始化
```C++
    int *pi = new int (6); // *pi set to 6
    double *pd = new double (99.99);
```
9. 名称空间是开放的,即可以把名称加入到已有的名称空间中
```C++
    namespace Pengzhen{
        string name;
        int age;
        string work;
        }
    namespace Pengzhen{
        int salary;
        }        
```
10. using声明使特定的标识符可用,using编译指令使整个名称空间可用;
11. 不允许使用using声明两个相同的标识符;
12. 如果名称空间和声明区域定义了相同的名称
    * 试图使用using声明将名称空间的名称导入该声明区域,那么会发生错误;
    * 如果使用using编译指令将该名称空间的名称导入该声明区域,则局部版本将隐藏名称空间版本;
13. 使用作用域解析运算符`::`或使用using声明比使用using编译指令更安全,因为如果发生错误时,编译器会给出提示;
14. 名称空间可以嵌套;
15. 未命名的名称空间相当于后面跟着using编译指令一样;
16. 尽量不要在头文件中使用using编译指令;
17. 如果开发了一个函数库或类库,将其放在一个名称空间中是一个不错的选择;    
18. 动态内存分配使用自由存储区或堆来存储数据;