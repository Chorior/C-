#Chapter 10: Object and Class
---
:hear_no_evil:
---
* 类是一种将抽象转换为用户定义类型的C++工具,它将数据表示和操纵数据的方法组合成一个简洁的包;
* 使用类对象的程序都可以直接访问公有部分,但只能通过公有成员函数来访问对象的私有成员;
* 使用私有成员函数来处理不属于公有接口中的实现细节;
* private是类对象的默认访问控制;
* public是结构的默认访问控制;
* 成员函数的函数头使用作用域运算符解析(::)来指出函数所属的类;
* 定义位于类声明中的函数都将自动成为内联函数;
* 内联函数的特殊规则要求每个使用它们的文件中都对其进行定义,最好把内联函数定义放在定义类的头文件中;
* 同一个类的所有对象共享同一组类方法,即每个方法只有一个副本;
* 类构造函数
    * 专门用于构造新对象初始化;
    * 构造函数名称与类名相同;
    * 构造函数没有声明类型;
    * 程序声明对象时,将自动调用构造函数;
    * 构造函数可以重载;
    * 如果没有提供任何构造函数,C++将自动提供默认构造函数,该构造函数不做任何工作;
    * 为类定义了构造函数后,最好为它提供默认构造函数,否则如`Stock stock1`将出错;
    * 定义默认构造函数的方式有两种
        * 给已有构造函数的**所有参数**提供默认值;
        * 通过函数重载定义一个没有参数的构造函数;
        * 只能有一个默认构造函数,不能同时采用上面两种方式;
    * C++提供两种构造函数来初始化对象
        * 显式调用构造函数,这将产生一个临时对象,赋值结束之后会将其丢弃  
        `Stock food = Stock("World Cabbage",250,1.25);`
        * 隐式调用构造函数  
        `Stock garment("Furry Mason",50,2.5);`
        * 最好使用隐式构造函数,那样效率更高;
    * 无法使用对象来调用构造函数,因为在构造函数构造出对象之前,对象是不存在的;
    * 隐式调用默认构造函数时,不要使用圆括号,`Stock second()`代表声明一个返回Stock对象的函数;
* 类析构函数
    * 专门用于在对象过期时完成对对象的清理工作;
    * 析构函数名称: 在类名前加上~;
    * 析构函数没有声明类型;
    * 析构函数没有参数,即不可以重载;
    * 如果没有提供析构函数,C++将自动隐式的声明一个默认析构函数,并在发现导致对象被删除的代码后,提供默认析构函数的定义;
* 自动变量放在栈中,最先创建的对象最后被删除;                      
* 如果类对象被创建为const对象,该对象调用一个没有参数的成员函数,如果该成员函数无法保证调用对象不被修改,那么将出现错误,解决办法是
    * 将const关键字放在函数的括号后面,如`void show() const`;
    * 上面语法保证函数不会修改调用对象;
    * 其定义的开头应该像这样: `void Stock::show() const`;
* 接受一个参数的构造函数允许使用赋值语法将对象初始化为一个值  
    `Stock stock1 = 32;`
* 返回一个私有成员值的函数设为内联函数特别方便;
* 所有类方法都将this指针设置为调用它的对象的地址;
* 声明对象数组的方法与声明标准类型数组相同,可以使用构造函数初始化数组元素
```C++
    Stock stocks[4] = {
        Stock("kahd",12.5,20),
        Stock("dada",200,2.0),
        Stock(),
        Stock()
        };
```   
* 初始化对象数组时,首先使用默认构造函数创建数组元素,然后将花括号中的构造函数创建的临时对象的内容复制到相应元素中,**因此,要创建类对象数组,这个类必须要有默认构造函数**; 
* 声明类只是描述了对象的形式,并没有创建对象,因此,在创建对象时,将没有用于存储值的空间,如下代码是错误的
```C++
    class Test
    {
    private: 
        const int Mouths = 12;
        double costs[Mouths];
        ...
    };
```
    * 有两种方法可以实现想要的效果
        * 使用枚举为整型常量提供作用域为整个类的符号名称
```C++
        class Test
        {
        private: 
            enum {Mouths = 12};
            double costs[Mouths];
            ...
        };
```
        * 使用static定义的常量将与其它静态变量存储在一起,而不是存储在对象中
```C++
        class Test
        {
        private: 
            static const int Mouths = 12;
            double costs[Mouths];
            ...
        };  
```
* 声明作用域为类的枚举量
    ```C++
    enum class egg {Small,Medium,Large,Jumbo};
    //enum struct egg {Small,Medium,Large,Jumbo};
    enum class t_shirt {Small,Medium,Large,Jumbo};
    //enum struct t_shirt {Small,Medium,Large,Jumbo};
    
    egg choice = egg::Large;
    t_shirt Floyd = t_shirt::Large;
    ```     
    * 作用域内的枚举量不能隐式地转换为整型,但可以进行显式转换
    ```C++
    int Frodo = int(t_shirt::Small);
    //int Frodo = (int)(t_shirt::Small);
    ```   
