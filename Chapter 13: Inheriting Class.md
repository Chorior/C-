#Chapter 13: Inheriting Class
---
:ear_of_rice:
---
* 如果成员中含有其它类,那么使用初始化列表的方式实现构造函数,也许可以省略调用其它类的构造函数和赋值运算符的步骤,所以尽量使用初始化列表实现构造函数;
* 使用公有派生,基类的公有成员将成为派生类的公有成员,基类的是有成员也将成为派生类的一部分,但只能通过基类的公有和保护方法访问;
* 派生类对象的特征
    * 派生类对象存储了基类的数据成员;
    * 派生类对象可以使用基类的方法;
    * 派生类需要自己的构造函数;
    * 派生类可以根据需要添加额外的数据成员和成员函数;
    * 创建派生类对象时,程序首先创建基类对象;
    * 派生类对象过期时,程序将首先调用派生类析构函数,然后再调用基类析构函数;
* 派生类构造函数
    * 派生类构造函数必须使用基类构造函数;
    * 如果派生类构造函数没有调用基类构造函数,程序会使用默认的基类构造函数;
    * 除非要使用默认的构造函数,否则应显式调用正确的基类构造函数;
    * 构造函数不能是虚的;
    * 派生类构造函数的要点
        * 首先创建基类对象;
        * 派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数;
        * 派生类构造函数应初始化派生类新增的数据成员;
* 派生类与基类之间的特殊关系
    * 基类指针可以在不进行显式类型转换的情况下指向派生类对象;
    * 基类引用可以在不进行显式类型转换的情况下引用派生类对象;
    * 基类指针或引用只能用于调用基类方法;
    * 不可以将基类对象和地址赋给派生类引用和指针;
    * 将派生类对象赋给基类对象,将把派生类对象的基类部分复制给基类对象对象;
* C++有三种继承方式
    * 公有继承;
    * 保护继承;
    * 私有继承;
* 基类与派生类方法
    * 如果方法没有使用关键字`virtual`,程序将根据引用类型或指针类型选择方法
    ```Ｃ++
        // behavior with non-virtual ViewAcct()
        
        Brass dom("Dominic Banker",11224,4183.45);
        BrassPlus dot("Dorothy Banker",12118,2592.00);
        Brass & b1_ref = dom;
        Brass & b2_ref = dot;
        
        b1_ref.ViewAcct(); // use Brass::ViewAcct()
        b2_ref.ViewAcct(); // use Brass::ViewAcct()
    ```     
    * 如果方法使用了关键字`virtual`,程序将根据引用或指针指向的对象的类型来选择方法
    ```C++
        // behavior with virtual ViewAcct()
        
        Brass dom("Dominic Banker",11224,4183.45);
        BrassPlus dot("Dorothy Banker",12118,2592.00);
        Brass & b1_ref = dom;
        Brass & b2_ref = dot;
        
        b1_ref.ViewAcct(); // use Brass::ViewAcct()
        b2_ref.ViewAcct(); // use BrassPlus::ViewAcct()
    ```         
    * 如果基类中的方法在派生类中重定义了,那么将其设为虚方法,即在原型前面加上`virtual`;
    * 关键字`virtual`只能用于类声明的方法原型中;
    * 使用虚函数时,在内存和执行速度方面有一定的成本
        * 每个对象都将增大,增大量为存储地址的空间;
        * 对于每个类,编译器都创建一个虚函数地址表;
        * 对于每个函数调用,都将到表中查找地址;
    * 在基类方法的虚函数会导致其派生类中的该方法也是虚的; 
    * 友元函数不能是虚函数,但友元函数可以使用虚函数;
    * 只有成员函数才能是虚函数;       
    * 如果虚函数没有被重新定义且派生类位于派生链中,那么将使用最新的虚函数版本;
    * 重新定义的函数无论参数列表是否相同,基类的同名方法将被隐藏;
    * 如果重新定义继承的方法,应确保与原来的原型完全相同,但如果返回的是基类引用或指针,则可以修改为指向派生类的引用或指针;这种例外只适用于返回值,不适用于参数;
    * 如果基类声明被重载了,则应在派生类中重新定义所有的基类版本,如果只定义了其中一些版本,那么其它版本将被隐藏,派生类对象无法使用它们;
    * 在派生类方法中,使用作用域解析运算符来调用基类方法,不使用作用域解析运算符将优先使用派生类方法,如果重定义的话;
* 基类与派生类析构函数
    * 若析构函数不是虚的,则将只调用对应于指针类型的析构函数;
    * 若析构函数是虚的,那么将调用对应对象类型的析构函数;
    * 使用虚析构函数可以保证正确的析构函数序列被调用;
* 静态联编: 在编译过程中进行联编,又称为早期联编;编译器对非虚方法使用静态联编;
* 动态联编: 编译器必须在程序运行时选择正确的虚方法的代码,又称为晚期联编;编译器对虚方法使用动态联编;                   
* 向上强制转换: 将派生类引用或指针转换为基类引用或指针;
* 向下强制转换: 将基类指针或引用转换为派生类指针或引用;如果不使用显式类型转换,则不允许向下强制转换;
* 关键字`protected`
    * 在类外只能使用公有类函数来访问protected部分的类成员;
    * 派生类的成员可以直接访问基类保护成员,但不能直接访问基类的私有成员;
    * 最好对类数据成员采用私有访问控制,不要使用保护访问控制,这时使用基类方法使派生类能够访问基类数据;
* 抽象基类(Abstract Base Class): 至少包含一个纯虚函数的类;
    * 纯虚函数: 在声明结尾处加上`= 0`;
    * 如果类声明中包含纯虚函数,那么不能创建该类的对象;
    * C++允许纯虚函数有定义;    
* 当基类和派生类都采用动态内存分配时,必须为派生类定义显式析构函数,复制构造函数和赋值运算符;
* 要使派生类的友元函数能够调用基类的友元函数,可以通过强制类型转换将派生类引用或指针转换为基类引用或指针,然后使用转换后的指针或引用进行调用;    