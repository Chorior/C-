#Chapter 12: Class and Dynamic Memory Allocation
---
:cherries:
---
* 如果静态成员变量不是const整型或枚举型,那么不能在类声明中初始化静态成员变量;
* 静态数据成员在类声明中声明,在包含类方法的文件中初始化,初始化时使用作用域运算符来指出静态成员所属的类;
* 静态类成员是单独存储的,而不是对象的组成部分;
* 删除对象可以释放对象本身占用的内存,但并不能自动释放属于对象成员的指针指向的内存;
* C++会自动为类提供如下成员函数
    * 默认构造函数,如果没有定义构造函数;
    * 默认析构函数,如果没有定义;
    * 复制构造函数,如果没有定义;
    * 赋值运算符,如果没有定义;
    * 地址运算符,如果没有定义;
* 类的复制构造函数
    * 原型
    ```C++
    Class_name(const Class_name &);
    ```
    * 每当新建一个对象并将其初始化为同类现有现象时,复制构造函数都将被调用;
    * 每当程序生成对象副本时,编译器都将使用复制构造函数,按值传递意味着创建原始变量的一个副本;
    * 当编译器生成临时对象时,将使用复制构造函数.例如三个对象相加时,可能生成临时对象保存中间值;
    * 当按值传递和返回对象时,都将调用复制构造函数;
* 尽量使用引用传递对象,可以节省调用构造函数的时间及存储新对象的空间;
* 如果类成员有使用new初始化的指针,那么定义复制构造函数,复制指向的数据而不是指针,会省去不必要的麻烦,这被称为深度复制;
* 重载的赋值运算符
    * 将已有的对象赋给另一个对象时,将使用重载的赋值运算符;
    * 赋值运算符是只能由类成员函数重载的运算符之一;
    * 原型: 
    ```C++
    Class_name & Class_name::operator=(const Class_name &);
    ```
    * 函数应该避免将对象赋给自身;
    * 如果目标对象不是自身,那么应该释放或删除已存在的对象;  
    * 示例
    ```C++
        ...
        StringBad & StringBad::operator=(const StringBad &st)
        {
            if(this == &st)
            {
                return *this;
            }
            delete []str;
            len = st.len;
            str = new char[len + 1];
            std::strcpy(str,st.str);
            return *this;        
        }
    ``` 
* 所有构造函数都应该与析构函数兼容;
* `str = new char[1];`与`str = new char;`分配的内存量相同,但前者使用`delete [] str;`释放,后者使用`delete str`释放;
* C使用NULL宏表示空指针,C++11使用nullptr表示空指针,建议使用nullptr;
* 静态成员函数
    * 不能通过对象调用静态成员函数;
    * 不能使用this指针调用静态成员函数;
    * 如果静态成员函数在公有部分声明,那么可以使用类名加作用域解析运算符调用它;
    * 静态成员函数只能使用静态数据成员,不能访问其它成员;
    * 静态成员函数在定义时不需要关键字static;
* 如果方法或函数返回局部对象,那么应该返回对象而不是对象的引用;    
* 如果方法或函数返回一个没有公有复制构造函数的类(如ostream类)的对象,那么应该返回一个指向这种对象的引用;
* 有些方法和函数可以返回对象也可以返回对象的引用,那么应该首选返回引用,这样效率更高;
* 在类声明中声明的结构,类或枚举被称为是被嵌套在类中,如果声明在公共部分,那么在类的外部通过使用作用域解析运算符使用被声明的类型;
* 成员初始化列表语法
    * 如果Classy是一个类,mem1,mem2,mem3是这个类的数据成员,那么类的构造函数可以使用如下语法来初始化数据成员
    ```C++
    Classy::Classy(int n, int m): mem1(n),mem2(0),mem3(n*m + 2)  
    {
        ...
    }
    ```
    * 上述代码将mem1初始化为n，mem2初始化为0,mem3初始化为n*m+2;
    * 这些初始化是在对象创建时完成的,此时还未执行花括号中的任何代码;
    * **这种格式只能用于构造函数**;
    * __必须用这种格式初始化非静态const数据成员__;
    * __必须使用这种格式初始化引用数据成员__;
    * 成员初始化列表也适用于常规初始化
    ```C++
    int games = 162;
    double talk = 2.71828;
    
    //equivalent conversion
    int games(162)；
    double talk(2.72828);
    ```
* 在C++11中,非静态const成员可以使用类内初始化,这与使用成员初始化列表等价,但实际初始化列表会覆盖类内初始化
```C++
   class Classy
   {
     int mem1 = 10;
     const int mem2 = 20;
     ...
   }
```                    
